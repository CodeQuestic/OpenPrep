---
title: Event Handling in React
---

import { Steps } from "@astrojs/starlight/components";
import { Tabs, TabItem } from "@astrojs/starlight/components";
import { Code } from "@astrojs/starlight/components";

React provides various ways to handle user events, such as clicks, input changes, and form submissions, through event handlers. Event handlers are functions that React calls in response to user interactions with UI elements.

## Common User Events in React

React supports several standard events that you can handle. Here are some commonly used ones:

### 1. Basic Event Handling

<Tabs>
  <TabItem label="onClick">
    <Code 
      code={`function Button() {
  const handleClick = () => {
    console.log('Button clicked!');
  };

return <button onClick={handleClick}>Click me</button>;
}`}
lang="jsx"
title="onClick Example"
/>

  </TabItem>
   <TabItem label="onChange">
    <Code 
      code={`function Input() {
  const [value, setValue] = useState('');
  
  const handleChange = (event) => {
    setValue(event.target.value);
  };

return <input type="text" value={value} onChange={handleChange} />;
}`}
lang="jsx"
title="onChange Example"
/>

  </TabItem>
   <TabItem label="onSubmit">
    <Code 
      code={`function Form() {
  const handleSubmit = (event) => {
    event.preventDefault();
    console.log('Form submitted!');
  };

return (
<form onSubmit={handleSubmit}>
<input type="text" />
<button type="submit">Submit</button>
</form>
);
}`}
lang="jsx"
title="onSubmit Example"
/>

  </TabItem>
   <TabItem label="KeyEvents">
    <Code 
      code={`function KeyHandler() {
  const handleKeyDown = (event) => {
    if (event.key === 'Enter') {
      console.log('Enter key pressed!');
    }
  };

return <input onKeyDown={handleKeyDown} placeholder="Press Enter" />;
}`}
lang="jsx"
title="onKeyDown Example"
/>

  </TabItem>
  <TabItem label="onFocus&onBlur">
    <Code 
      code={`function FocusHandler() {
  const [isFocused, setIsFocused] = useState(false);

const handleFocus = () => setIsFocused(true);
const handleBlur = () => setIsFocused(false);

return (
<div>
<input
onFocus={handleFocus}
onBlur={handleBlur}
placeholder="Focus on me"
style={{ borderColor: isFocused ? 'blue' : 'gray' }}
/>
<p>{isFocused ? 'Input is focused' : 'Input is not focused'}</p>
</div>
);
}`}
lang="jsx"
title="onFocus & onBlur Example"
/>

  </TabItem>
  <TabItem label="MouseEvents">
    <Code 
      code={`function MouseHandler() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

const handleMouseMove = (event) => {
setPosition({ x: event.clientX, y: event.clientY });
};

return (
<div
onMouseMove={handleMouseMove}
style={{ height: '200px', border: '1px solid black' }} >
<p>Mouse position: ({position.x}, {position.y})</p>
</div>
);
}`}
lang="jsx"
title="onMouseMove Example"
/>

  </TabItem>
  <TabItem label="onScroll">
    <Code 
      code={`function ScrollHandler() {
  const [scrollY, setScrollY] = useState(0);

const handleScroll = () => {
setScrollY(window.scrollY);
};

useEffect(() => {
window.addEventListener('scroll', handleScroll);
return () => window.removeEventListener('scroll', handleScroll);
}, []);

return <div>Scroll position: {scrollY}</div>;
}`}
lang="jsx"
title="onScroll Example"
/>

  </TabItem>
</Tabs>

## Class Components vs Functional Components

Event handling differs slightly between class and functional components:

<Tabs>
  <TabItem label="ClassComponent">
    <Code 
      code={`class ClassComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    
    // Binding is required for class methods
    this.handleClick = this.handleClick.bind(this);
  }

handleClick() {
this.setState({ count: this.state.count + 1 });
}

render() {
return (
<div>
<p>Count: {this.state.count}</p>
<button onClick={this.handleClick}>Increment</button>
</div>
);
}
}`}
lang="jsx"
title="Class Component Event Handling"
/>

  </TabItem>
  <TabItem label="FunctionalComponent">
    <Code 
      code={`function FunctionalComponent() {
  const [count, setCount] = useState(0);

const handleClick = () => {
setCount(count + 1);
};

return (
<div>
<p>Count: {count}</p>
<button onClick={handleClick}>Increment</button>
</div>
);
}`}
lang="jsx"
title="Functional Component Event Handling"
/>

  </TabItem>
</Tabs>

## Event Object and SyntheticEvent

React wraps native events in `SyntheticEvent` objects to provide consistent behavior across browsers:

<Tabs>
  <TabItem label="EventObject">
    <Code 
      code={`function EventInfo() {
  const handleEvent = (event) => {
    console.log('Event type:', event.type);
    console.log('Target element:', event.target);
    console.log('Current target:', event.currentTarget);
    console.log('Native event:', event.nativeEvent);
    
    // Prevent default behavior
    event.preventDefault();
    
    // Stop event propagation
    event.stopPropagation();
  };

return (
<div onClick={handleEvent}>
<button onClick={handleEvent}>Click me</button>
</div>
);
}`}
lang="jsx"
title="SyntheticEvent Properties"
/>

  </TabItem>
  <TabItem label="CustomData">
    <Code 
      code={`function CustomEventData() {
  const handleClick = (event, customData) => {
    console.log('Custom data:', customData);
    console.log('Event:', event.type);
  };

return (
<div>
<button onClick={(e) => handleClick(e, 'Button 1')}>
Button 1
</button>
<button onClick={(e) => handleClick(e, 'Button 2')}>
Button 2
</button>
</div>
);
}`}
lang="jsx"
title="Passing Custom Data"
/>

  </TabItem>
</Tabs>

## Synthetic Events in React

React uses synthetic events to wrap native DOM events, providing a consistent interface across different browsers. Synthetic events help React maintain cross-browser compatibility and improve performance.

### Advantages of Synthetic Events

#### 1. Cross-Browser Consistency

- Different browsers have historically handled event properties slightly differently. For example, properties like `event.target` and `event.currentTarget` may vary in behavior across browsers.
- React's synthetic events ensure that commonly accessed properties (such as `target`, `type`, `key`, and `button`) behave in a predictable, uniform way on all supported browsers. This makes event handling code more reliable, as you won't need to include browser-specific checks.

#### 2. Unified Event Methods

- Functions such as `preventDefault()` and `stopPropagation()` may have browser-specific implementations. React's synthetic events standardize these methods, so they always work the same way.
- For example, `event.preventDefault()` will prevent the default action across all browsers, and `event.stopPropagation()` will reliably stop the event from bubbling up, regardless of the browser in use.

#### 3. Handling Event Variations (e.g., Pointer Events)

- Browsers may vary in their support for different types of input events like `mouse`, `touch`, or `pointer` events. React's synthetic event system normalizes these variations, making it easier to write code that works for multiple input types without extra handling.

#### 4. Event Pooling in Synthetic Events

- React employs event pooling as a performance optimization. When an event is triggered, React reuses a synthetic event object from a pool, which reduces the need to create new event objects and saves memory. However, this also means that properties of synthetic events are reset after the event handler executes.
- To access the event properties asynchronously (such as in a timeout or asynchronous function), you must call `event.persist()` to retain the event's values.

**Example:**

<Tabs>
  <TabItem label="Pooling">
    <Code 
      code={`import React from 'react';

function PoolingExample() {
const handleClick = (event) => {
// Access event properties immediately
console.log('Immediate access:', event.type);

    // For async operations, persist the event
    event.persist();

    setTimeout(() => {
      // This works because we called persist()
      console.log('Async access:', event.type);
      console.log('Target:', event.target.tagName);
    }, 1000);

};

return (
<button onClick={handleClick}>
Click me to see event pooling in action
</button>
);
}

export default PoolingExample;`}
      lang="jsx" 
      title="Pooling.jsx" 
    />
    Calling `event.persist()` allows us to use the event properties even after the event handler has finished execution, which is useful for asynchronous operations.
  </TabItem>
</Tabs>

### Performance and Compatibility Implications

- **Performance**: By pooling events and reusing objects, React improves memory efficiency, which can be beneficial for applications with frequent event handling, such as games or animations.
- **Compatibility**: Synthetic events eliminate browser-specific inconsistencies, making it simpler for developers to write code that works uniformly across environments.

## Passing Arguments to Event Handlers

There are several ways to pass arguments to event handlers:

<Tabs>
  <TabItem label="ArrowFunction">
    <Code 
      code={`function ListComponent() {
  const items = ['Apple', 'Banana', 'Cherry'];

const handleItemClick = (item, index, event) => {
console.log('Clicked item:', item);
console.log('At index:', index);
console.log('Event:', event.type);
};

return (
<ul>
{items.map((item, index) => (
<li key={index}>
<button onClick={(e) => handleItemClick(item, index, e)}>
{item}
</button>
</li>
))}
</ul>
);
}`}
lang="jsx"
title="Arrow Function Approach"
/>

  </TabItem>
  <TabItem label="BindMethod">
    <Code 
      code={`class ListComponent extends React.Component {
  handleItemClick = (item, index, event) => {
    console.log('Clicked item:', item);
    console.log('At index:', index);
    console.log('Event:', event.type);
  };

render() {
const items = ['Apple', 'Banana', 'Cherry'];

    return (
      <ul>
        {items.map((item, index) => (
          <li key={index}>
            <button onClick={this.handleItemClick.bind(this, item, index)}>
              {item}
            </button>
          </li>
        ))}
      </ul>
    );

}
}`}
lang="jsx"
title="Bind Method Approach"
/>

  </TabItem>
  <TabItem label="DataAttributes">
    <Code 
      code={`function ListComponent() {
  const items = ['Apple', 'Banana', 'Cherry'];

const handleItemClick = (event) => {
const item = event.target.dataset.item;
const index = event.target.dataset.index;

    console.log('Clicked item:', item);
    console.log('At index:', index);
    console.log('Event:', event.type);

};

return (
<ul>
{items.map((item, index) => (
<li key={index}>
<button 
            data-item={item} 
            data-index={index} 
            onClick={handleItemClick}
          >
{item}
</button>
</li>
))}
</ul>
);
}`}
lang="jsx"
title="Data Attributes Approach"
/>

  </TabItem>
</Tabs>

## Best Practices for Event Handling

### Choosing the Right Approach

Different approaches have different performance implications:

- **Arrow Functions**
- **Function Binding**
- **Curried Function**

<Tabs>
  <TabItem label="Performance">
    <Code 
      code={`// ✅ Good: Function defined outside render
function GoodExample() {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  return (
    <div>
      <ChildComponent onClick={handleClick} />
      <p>Count: {count}</p>
    </div>
  );
}

// ❌ Poor: New function created on each render
function BadExample() {
const [count, setCount] = useState(0);

return (
<div>
<ChildComponent onClick={() => setCount(count + 1)} />
<p>Count: {count}</p>
</div>
);
}`}
lang="jsx"
title="Performance Considerations"
/>

  </TabItem>
  <TabItem label="Accessibility">
    <Code 
      code={`function AccessibleButton() {
  const handleClick = () => {
    console.log('Button clicked');
  };
  
  const handleKeyPress = (event) => {
    if (event.key === 'Enter' || event.key === ' ') {
      handleClick();
    }
  };
  
  return (
    <button 
      onClick={handleClick}
      onKeyPress={handleKeyPress}
      aria-label="Custom action button"
      role="button"
      tabIndex={0}
    >
      Click me
    </button>
  );
}`}
      lang="jsx"
      title="Accessibility Best Practices"
    />
  </TabItem>
</Tabs>

### Pros and Cons

#### Arrow Functions

- **Pros:**
- Clear and explicit.
- Easy to pass multiple arguments.
- Access to the event object.
- No binding required.

- **Cons:**
- Creates a new function on each render.
- Slightly worse performance in high-frequency updates.
- May cause unnecessary re-renders in child components.

#### Function Binding

- **Pros:**
- Only creates the function once.
- Better performance for frequent updates.
- Works well with class components.

- **Cons:**
- Less readable syntax.
- Can be confusing for beginners.
- Requires understanding of `this` binding.

#### Data Attributes

- **Pros:**
- Single event handler function.
- Best performance for large lists.
- Clean HTML structure.

- **Cons:**
- Data is passed as strings only.
- Requires parsing for complex data types.
- Less explicit about what data is being passed.

## Conclusion

Event handling is a fundamental concept in React that enables interactive user interfaces. Understanding synthetic events, proper event handler patterns, and performance implications will help you build more efficient and maintainable React applications.

Key takeaways:

- Use synthetic events for cross-browser compatibility
- Be mindful of performance when creating event handlers
- Choose the right approach based on your specific use case
- Always consider accessibility when handling events
- Leverage React's event system for optimal performance
