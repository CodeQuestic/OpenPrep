---
title: Hooks in React
---

### Introduction to Hooks

React Hooks were introduced in React 16.8 to simplify how developers manage state and side effects in functional components. Before Hooks, functional components were stateless, and only class components could hold state or use lifecycle methods. This often led to complex class structures and repetitive code. Hooks solve this by allowing developers to use state and other React features directly in functional components, making the code cleaner and easier to manage.

### Pros of React Hooks

 - **Simplify Code** : With class components, developers had to deal with this, binding methods, and complex lifecycle methods. Hooks eliminate these issues by keeping everything in functional components, which are easier to write and maintain.
 - **Reuse Logic** : Before Hooks, reusing logic across components was challenging. Developers had to rely on patterns like higher-order components (HOCs) or render props, which made the code harder to follow. Hooks, especially custom hooks, enable the reuse of logic more naturally, without modifying the component tree structure.
 - **Clean Code** : Class components often resulted in code that mixed stateful logic with UI concerns. Hooks let developers separate different pieces of logic (e.g., managing form state, fetching data) into smaller, isolated functions, leading to better-organized code.

### Rules of Hooks

1. **Call Hooks Only at the Top Level**

Hooks should only be called at the top level of your component, not inside loops, conditions, or nested functions. This ensures that Hooks are called in the same order on every render, which is crucial for React to correctly preserve the component’s state between renders.

```jsx
// Correct usage
function MyComponent() {
    const [count, setCount] = useState(0); // Hook at the top level
}

// Incorrect usage
function MyComponent() {
    if (someCondition) {
        useState(0); // Hook inside a condition – this will cause issues
    }
}
```

2. **Call Hooks Only in React Functions**

Hooks should only be called inside functional components or custom hooks, not in regular JavaScript functions or class components. This is to ensure that React can properly manage the component's state.

```jsx
// Correct usage
function MyComponent() {
    const [count, setCount] = useState(0);
}

// Incorrect usage
function regularFunction() {
    useState(0); // Can't call a Hook here
}
```

React Hooks fundamentally changed how developers write and manage functional components, making them more powerful and easier to understand. By adhering to the rules of hooks and leveraging them for state management, side effects, and reusable logic, developers can create cleaner, more maintainable code.

### Basic Hooks

React provides several hooks that allow you to handle common tasks like managing state and handling side effects in functional components. Two of the most important and widely used hooks are useState and useEffect.


### `useState` : Managing State in Functional components

The useState hook is used to add state to functional components. Before hooks, only class components could have state. Now, with useState, any functional component can manage its own state.

The useState hook allows you to declare a state variable and a function to update that state. When you call useState, you pass the initial state as an argument, and it returns an array with two elements:
 - The current state
 - A function that updates the state

**Syntax of `useState`**

```jsx
const [stateVariable, setStateVariable] = useState(initialValue);
```
 - `stateVariable` : This is the current value of the state.
 - `setStateVariable` : This is a function used to update the value of stateVariable.
 - `initialValue` : This is the starting value for the state.

### Example of `useState`

```jsx
import React, { useState } from 'react';

function Counter() {
    // Declare a state variable 'count' initialized to 0
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={() => setCount(count + 1)}>
                Click me
            </button>
        </div>
    );
}
```

In this example:

We declare a state variable `count` and a function `setCount` to update it. `useState(0)` initializes count to 0. When the button is clicked, `setCount` is called with the new value (count + 1), which re-renders the component with the updated state.

### Initializing state with Function

Sometimes, initializing state might involve a heavy calculation. You can pass a function to useState to compute the initial state only once when the component first renders.

```jsx
const [state, setState] = useState(() => {
    // Complex calculation to determine the initial state
    return someExpensiveCalculation();
});
```

### State Updation

When updating state based on the current state (e.g., incrementing or toggling values), you can pass a function to setState. This ensures you’re working with the latest state value.

```jsx
<button onClick={() => setCount(prevCount => prevCount + 1)}>
    Increment
</button>
```

### `useEffect` : Handling Side effects

The `useEffect` hook is used to handle side effects in functional components. Common side effects include data fetching, subscriptions, and directly interacting with the DOM. Before hooks, these kinds of side effects were managed using lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` in class components. `useEffect` combines all of these into one unified API. Basically, it takes two arguments
 - A function where you define the side effect.
 - An optional dependency array that controls when the effect should run.

**Syntax of `useEffect`**

```jsx
useEffect(() => {
    // Code for the side effect
}, [dependencies]);
```

Side effect function is the function that runs after each render, performing the desired effect (e.g., fetching data).
Dependency is an optional array that specifies when the effect should re-run. If a value in the array changes, the effect will re-run.

### Example of `useEffect`

```jsx
import React, { useState, useEffect } from 'react';

function DataFetchingComponent() {
    const [data, setData] = useState([]);

    useEffect(() => {
        // Fetch data from an API when the component mounts
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data));
    }, []); // Empty array means this effect runs only once, when the component mounts

    return (
        <div>
            {data.map(item => (
                <p key={item.id}>{item.name}</p>
            ))}
        </div>
    );
}
```

In this example: The side effect is fetching data from an API when the component first renders. The [] (empty dependency array) ensures the effect only runs once, similar to `componentDidMount`.

### Controlling using Dependency array

You can control when an effect runs by adding dependencies. The effect will only run again if one of the dependencies changes.

```jsx
useEffect(() => {
    // This effect runs when 'count' changes
    console.log(`The count is now ${count}`);
}, [count]); // Effect runs only when 'count' changes
```

### Cleaning up effects

Sometimes, side effects like subscriptions or timers need to be cleaned up to prevent memory leaks. `useEffect` can return a cleanup function that runs when the component unmounts or before the effect re-runs.

```jsx
useEffect(() => {
    const timer = setInterval(() => {
        console.log('This runs every second');
    }, 1000);
    // Cleanup the timer when the component unmounts
    return () => {
        clearInterval(timer);
    };
}, []);
```

### Additional Hooks

### `useContext` : Accessing Global State with React’s Context API

The useContext hook is used to access values provided by the Context API in React. The Context API allows you to create and manage global state, which can be shared across different components without passing props down through every level of the component tree. This is particularly useful for managing themes, authentication status, or user settings that are needed by many components

useContext allows a component to consume the nearest Context Provider’s value without needing to pass props through intermediate components. This helps reduce "prop drilling" (passing props down multiple levels) and makes the code more readable.

**Steps to use `useContext`**

 - First, create a context using React.createContext(). This provides a default value for the context.

 ```jsx
 const MyContext = React.createContext(defaultValue);
```

 - Wrap your component tree with a Context Provider to supply a value that child components can consume.

```jsx
<MyContext.Provider value={someValue}>
    <ChildComponent />
</MyContext.Provider>
```

 - Use the useContext hook inside any component that needs the context value.

 ```jsx
 const value = useContext(MyContext);
```

### Example of `useContext`

```jsx
import React, { createContext, useContext } from 'react';

const MyContext = createContext('default value');

function DisplayComponent() {
    const value = useContext(MyContext);  // Access the context value
    return <p>Context Value: {value}</p>;
}

function App() {
    return (
        <MyContext.Provider value="Hello, World!">
            <DisplayComponent />
        </MyContext.Provider>
    );
}
```

In this example, `DisplayComponent` accesses the value "Hello, World!" from `MyContext` using `useContext`.

### `useRef` : Referencing DOM Elements and Persisting Values

The `useRef` hook is used to reference DOM elements or persist values across renders without causing the component to re-render. Unlike state variables, changing a `useRef` value does not trigger a re-render.

You can use `useRef` to directly access a DOM element, such as focusing an input field or scrolling to a specific section. `useRef` can store a mutable value that persists between renders, without triggering re-renders when the value changes.

```jsx
const refContainer = useRef(initialValue);
```

`useRef` returns a mutable object that has a single property called current. The current property of the object can hold any value (similar to an instance variable in class components) and is preserved across renders.

### Example of `useRef`

```jsx
import React, { useRef } from 'react';

function FocusInput() {
    const inputRef = useRef(null); // Create a ref
    const focusInputField = () => {
        inputRef.current.focus(); // Access the input element and focus it
    };
    return (
        <div>
            <input ref={inputRef} type="text" />
            <button onClick={focusInputField}>Focus the input</button>
        </div>
    );
}

export default FocusInput;
```

### `useReducer` : Managing Complex State

The `useReducer` hook is an alternative to `useState` for managing state, particularly when the state logic is complex or the state has multiple sub-values that need updating in various ways. It is often used in large-scale applications or for cases where `useState` would result in messy, hard-to-maintain code.

`useReducer` is similar to the `reduce` function in JavaScript. It takes a reducer function and an initial state as arguments and returns:
 - The current state.
 - A dispatch function to send actions to the reducer.

**Syntax of `useReducer`

```jsx
const [state, dispatch] = useReducer(reducerFunction, initialState);
```

 - `reducerFunction` : This is a function that takes the current state and an action, then returns the new state.
 - `initialState` : This is the initial value of the state.
 - `dispatch` : This function is used to send actions that update the state.

### Example of `useReducer`

```jsx
import React, { useReducer } from 'react';

function counterReducer(state, action) {
    switch (action.type) {
        case 'increment':
            return { count: state.count + 1 };
        case 'decrement':
            return { count: state.count - 1 };
        default:
            return state;
    }
}

function Counter() {
    const [state, dispatch] = useReducer(counterReducer, { count: 0 });

    return (
        <div>
            <p>Count: {state.count}</p>
            <button onClick={() => dispatch({ type: 'increment' })}>+</button>
            <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
        </div>
    );
}
```

In this example, useReducer manages simple increment and decrement actions for a counter.

### 