---
title: Introduction to Node.js
---

import { Steps } from "@astrojs/starlight/components";
import { Code } from "@astrojs/starlight/components";
import { FileTree } from "@astrojs/starlight/components";
import { Tabs, TabItem } from "@astrojs/starlight/components";
import snippet from "./codes/introductionCode/introduction.txt?raw";

## What is Node.js?

Node.js is an open-source, cross-platform JavaScript runtime environment built on Chrome's V8 JavaScript engine. It enables developers to use JavaScript for server-side scripting—running scripts on the server to produce dynamic web page content before the page is sent to the user's web browser.

Traditionally, JavaScript was used only in the browser, but Node.js extends the capabilities of JavaScript beyond the browser, making it suitable for building scalable, high-performance backend services like APIs, web servers, and microservices.

## Node.js Architecture

Node.js uses a single-threaded, event-driven architecture that handles many concurrent connections efficiently. Here's how it works:

- **Event Loop**: At the heart of Node.js is the event loop. Instead of creating a new thread for each client request (like traditional multi-threaded architectures), Node.js uses an event loop to manage all operations. When a request comes in, it's placed in the event queue, and the event loop processes each request one at a time.
- **Non-Blocking I/O**: Node.js uses non-blocking, asynchronous I/O operations. This means that operations like file reads or database calls are performed in the background while the server continues to handle other requests, improving performance and scalability.

- **Libuv**: This is the library responsible for handling asynchronous operations such as file systems, networking, and more. It provides the event loop and manages threads in a thread pool for operations that cannot be done asynchronously.

- **Chrome V8 Engine**: Node.js is built on Chrome's V8 JavaScript engine, which compiles JavaScript into machine code. This gives Node.js the speed and performance it needs to handle large-scale applications.

## How Node.js Operates

1. **Single-Threaded**: Node.js operates on a single thread but uses asynchronous I/O to handle multiple operations concurrently. This avoids the overhead of managing multiple threads but requires a different approach to writing code (often using callbacks, promises, or async/await patterns).
2. **Event-Driven**: Events drive everything in Node.js. Whether you're handling an HTTP request or reading a file, events trigger these actions, and the event loop manages how they are processed.

3. **Modular**: Node.js applications are modular, meaning you can break your code into smaller pieces (modules) and import only what you need. The Node Package Manager (NPM) provides a massive repository of reusable modules that you can use in your projects.

With this architecture, Node.js is well-suited for applications that need to handle many concurrent connections, such as real-time applications (e.g., chat apps, live streaming), REST APIs, and more.

## Features of Node.js

Node.js has several core features that make it a powerful and popular choice for modern applications:

### 1. Non-blocking I/O

One of the most important features of Node.js is its **non-blocking I/O** model. In traditional web servers, I/O operations like reading files, accessing databases, or making network requests block the execution of other operations. Node.js, on the other hand, performs these I/O operations asynchronously, allowing other processes to continue running without waiting for the I/O operation to complete. This non-blocking nature enables Node.js to handle many concurrent operations efficiently, making it ideal for applications with high input/output demands.

### 2. Single-threaded Event Loop

Node.js operates on a **single-threaded event loop**, meaning that it handles multiple client requests with a single thread. While this may seem limiting, the event-driven architecture allows Node.js to manage multiple operations simultaneously without creating additional threads. The event loop continuously checks for tasks in the event queue and processes them one by one. When an asynchronous task completes (e.g., a file read), the event loop picks it up and processes the response. This enables Node.js to handle thousands of connections at once with minimal resource consumption.

### 3. Asynchronous Programming Model

Node.js embraces an **asynchronous programming model**, where tasks that might take time, like network or file system operations, are performed in the background. Developers can use patterns such as **callbacks**, **promises**, or **async/await** to manage these asynchronous operations. This model makes applications faster and more responsive since tasks are not blocked while waiting for long-running operations to complete. Asynchronous programming also allows for better handling of concurrency compared to traditional multi-threaded models, where thread management and context switching can introduce overhead.

---

## Use Cases for Node.js

Node.js shines in various real-world applications due to its efficient, non-blocking architecture. Here are some scenarios where Node.js is particularly beneficial:

### 1. Web Servers and REST API's

Node.js is widely used to create **web servers** and **RESTful APIs** that handle multiple requests simultaneously. Its ability to process many client requests without creating multiple threads makes it an ideal choice for **high-traffic websites** and **API-driven applications**. For example:

- **PayPal** rebuilt its server-side web applications using Node.js, reducing response times by 35%.
- **Netflix** also uses Node.js to streamline its server-side operations, ensuring efficient handling of millions of requests from users globally.

### 2. Real-Time Applications

Node.js is the go-to technology for building **real-time applications**, such as **chat applications**, **collaboration tools**, and **online gaming platforms**. The event-driven, asynchronous architecture ensures low-latency updates and fast data synchronization across connected clients. Real-time applications using Node.js include:

- **Slack**, the popular team communication tool, uses Node.js for its real-time messaging functionality.
- **Trello**, the project management app, utilizes Node.js for delivering live updates to users’ boards, making collaboration seamless.

### 3. Streaming Applications

Due to its asynchronous nature, Node.js is perfect for handling **streaming data**. Streaming applications need to process data chunks without loading everything into memory, and Node.js can efficiently manage such real-time streaming requirements. Some examples include:

- **Netflix**, which uses Node.js to handle data streaming for its users.
- **Twitch**, the live-streaming platform for gamers, leverages Node.js to manage video streams and interactions with minimal latency.

### 4. Microservices Architecture

Node.js is highly modular, making it well-suited for applications built using **microservices architecture**. With Node.js, developers can create small, independent services that are easy to scale and manage. For instance:

- **Walmart** uses Node.js to manage its microservices, handling millions of user interactions daily, with high performance and scalability.

### 5. Internet of Things (IoT)

Node.js is a strong contender for **IoT applications** that require handling many requests and device interactions at once. Its event-driven nature allows it to efficiently process data from sensors and devices in real time, making it ideal for use cases such as:

- **Smart homes**, where multiple devices like thermostats, lights, and security systems communicate in real time.
- **Smart city projects** that involve processing data from thousands of sensors for real-time decision-making.

## Comparison with Other Technologies

When choosing a backend technology, it's important to consider the specific requirements of your project. Here's how Node.js compares with other popular backend technologies like Python and PHP, focusing on their strengths and weaknesses.

### 1. Node.js vs Python

#### Strengths of Node.js:

- **Performance**: Node.js is built on the **V8 JavaScript engine**, making it extremely fast, especially for handling I/O-bound tasks. Its **non-blocking, event-driven architecture** allows it to process many requests concurrently, which is ideal for real-time applications like chat apps or online gaming.
- **Scalability**: Node.js' asynchronous, single-threaded nature allows for easier scaling, making it suitable for handling large-scale, distributed systems.
- **Same language across stack**: With Node.js, developers can use JavaScript for both frontend and backend development, promoting full-stack development with a unified codebase.

#### Weaknesses of Node.js:

- **CPU-bound operations**: While Node.js excels in handling I/O-bound tasks, it may struggle with **CPU-intensive tasks** like complex calculations, which can block the event loop and slow down performance.

#### Strengths of Python:

- **Simplicity and Readability**: Python's syntax is clean and easy to understand, which makes it a preferred language for developers who prioritize development speed and readability.
- **Extensive Libraries**: Python has a vast ecosystem of libraries, particularly for **data science**, **machine learning**, and **scientific computing**, making it the go-to language for these fields.
- **Multi-threading support**: Python supports multi-threading more effectively, which makes it more suitable for CPU-intensive tasks like data processing or AI model training.

#### Weaknesses of Python:

- **Performance**: Python's performance, especially when handling a large number of concurrent connections, is generally slower than Node.js due to Python's synchronous nature.
- **Concurrency**: Python's **Global Interpreter Lock (GIL)** limits its ability to execute multiple threads at once, which can be a bottleneck for highly concurrent applications.

#### When to Choose Node.js Over Python?

If you're building an I/O-bound, real-time application like a chat platform, gaming server, or API gateway, Node.js is often the better choice due to its event-driven, non-blocking architecture. However, for data-driven tasks, machine learning, or scientific computing, Python is a stronger contender.

### 2. Node.js vs PHP

#### Strengths of Node.js:

- **Asynchronous I/O**: Node.js handles asynchronous I/O natively, enabling it to handle multiple concurrent requests efficiently. This makes it perfect for real-time applications like collaborative tools and streaming platforms.
- **JavaScript across the stack**: Like Python, Node.js allows developers to use a single language—JavaScript—across the frontend and backend, which increases development efficiency and collaboration.

#### Weaknesses of Node.js:

- **Younger ecosystem**: While Node.js has a rapidly growing ecosystem, it is still younger than PHP, meaning it may not have the same depth of community-provided libraries and tools for specific tasks.

#### Strengths of PHP:

- **Maturity and stability**: PHP is one of the oldest web development languages, meaning it has a vast ecosystem of tools, frameworks (like Laravel and Symfony), and community support.
- **Ease of deployment**: PHP is designed for web development and can be easily deployed on almost any web hosting service, thanks to its close integration with web servers like Apache and Nginx.
- **Simplicity**: PHP is straightforward to set up, making it ideal for quickly building small- to medium-sized web applications.

#### Weaknesses of PHP:

- **Synchronous nature**: PHP is traditionally synchronous, meaning each request blocks the next until it's finished. This can lead to scalability issues when handling large numbers of requests.
- **Performance**: PHP generally performs slower than Node.js in applications that require high concurrency, such as real-time messaging apps or API servers.

#### When to Choose Node.js Over PHP?

If you’re developing an application that requires high concurrency, low-latency responses, and real-time updates—such as a live streaming service or a real-time collaboration tool—Node.js will outperform PHP due to its non-blocking, asynchronous architecture. However, PHP might be a better choice for simple websites or CMS-driven projects where ease of deployment and a mature ecosystem are priorities.

### 3. Quick Comparison

| Feature               | Node.js                             | Python                             | PHP                               |
| --------------------- | ----------------------------------- | ---------------------------------- | --------------------------------- |
| **Performance**       | Excellent for I/O-bound tasks       | Slower for concurrent requests     | Slower for highly concurrent apps |
| **Concurrency**       | Single-threaded, non-blocking I/O   | Limited by Global Interpreter Lock | Synchronous, blocking by default  |
| **Best for**          | Real-time apps, APIs, microservices | Data science, machine learning     | CMS, small- to medium-sized apps  |
| **Ecosystem**         | Growing rapidly                     | Mature with extensive libraries    | Very mature, especially for web   |
| **Development speed** | Fast with JavaScript across stack   | Fast, easy to learn                | Fast, easy to deploy              |

## Basic Installation Steps for Node.js

    <Steps>

    1. **Download Node.js**:

       - Visit the official Node.js website: [Node.js Official Website](https://nodejs.org).
       - Download the recommended version for your operating system (LTS is recommended for most users).

    2. **Install Node.js**:

       - Run the installer you downloaded.
       - Follow the installation prompts, which usually involves agreeing to the license agreement and choosing the installation path.

    3. **Verify Installation**:

       - Open a terminal or command prompt and run the following commands to check if Node.js and npm (Node Package Manager) are installed correctly:

         ```bash
         node -v
         npm -v
         ```

    </Steps>

## Code Editor:

        **Visual Studio Code (VS Code)**:
            - Lightweight and feature-rich.
            - Install it from the [official website](https://code.visualstudio.com/).

        **Recommended extensions**:
            - **Node.js Extension Pack**: Adds debugging, IntelliSense, and tools for Node.js.
            - **ESLint**: Helps in identifying and fixing coding errors.
            - **Prettier**: Automatically formats your code.

## Version Control: Git

    Version control helps you manage code changes effectively.
        - Install Git from the official website.
        - Set up Git in your project directory:
         ```bash
        git init
        git config --global user.name "Your Name"
        git config --global user.email "your.email@example.com"
        ```

## Project Setup

    Start by creating a new Node.js project:

    <Steps>

    1. **Download Node.js**:

        ```bash
        mkdir my-node-project
        cd my-node-project
        ```
    2. **Initialize the project**:

        ```bash
        npm init -y
        ```

    </Steps>

## Useful NPM Packages

    Some essential packages to install right away:
        - Express: A minimalist web framework to install use **npm install express**.
        - Nodemon: Automatically restarts the server when you make changes use **npm install --save-dev nodemon**.
        - dotenv: Manages environment variables **npm install dotenv**.

## Folder Structure

A good folder structure keeps your code organized.

<FileTree>

- my-node-project
  - node_modules Contains all project dependencies.
    - .bin
    - ... Other dependencies.
  - config
    - db.js Configures and connects to the database.
  - controllers
    - userController.js Contains API logic & operations.
  - models
    - userModel.js Defines the schema and model for Database.
  - routes
    - route.js Defines and manages all application routes.
  - .env Stores environment variables like API keys.
  - index.js Main server entry point.
  - .gitignore Lists files and folders to ignore.
  - package-lock.json (if using npm)
  - package.json Contains project metadata and dependency list.

</FileTree>

## Creating Your First Node.js Application

---

### Steps to Create Your First Node.js Project

1. **Create a folder** on your system and open it in your code editor.
2. **Open the terminal** and run `npm init -y`; this will add a new file called `package.json`.
3. **Create a file named `index.js`** and add your JavaScript code.
4. **To see the output**, add `"start": "node index.js"` in the `"scripts"` section of `package.json`, then run `npm start` in the terminal.

```js
// index.js
console.log("Hello, Node.js!");
```

Inside your project folder, create a file called index.js, which will serve as your main application file. To set up a basic Express server, start by requiring the Express module and configuring a simple server. In the index.js file, import Express and define a route for the homepage that responds with a message. Finally, set the server to listen on a specified port, such as 3000, and log a message indicating that the server is running. This establishes the foundation for your Node.js application using Express.

### First Node.js Project with express

<Tabs>
  <TabItem label="Dependencies">
    Install the following library.
    <Code code={`npm install express`} lang="shell" />
  </TabItem>
  <TabItem label="Snippet">
    <Code code={snippet} lang="js" title="index.js" />
  </TabItem>
</Tabs>

## Event Looping

The event loop is one of the most important concepts in Node.js, enabling it to handle asynchronous operations and manage concurrency efficiently. At its core, the event loop allows Node.js to perform non-blocking I/O operations, even though JavaScript itself runs on a single thread.
The event loop is what allows Node.js to perform efficiently. It can handle thousands of connections without creating new threads for each one. Instead, it manages tasks in the background (asynchronously) and only returns to them when necessary, minimizing resource usage.

#### How Does It Work?

1.  **Single Threaded Nature:**: Node.js runs JavaScript code on a single thread. This means only one piece of code executes at a time. However, through the event loop, Node.js can handle multiple tasks without waiting for one to finish before starting another.
2.  **Asynchronous Operations**: Many operations in Node.js (like reading files, querying databases, or making HTTP requests) can take time. Instead of waiting for these tasks to complete, Node.js continues executing other code. This is where the event loop shines.

3.  **The Phases of the Event Loop:**: The event loop has several phases where it checks for tasks to execute:

        - **Timers**: Executes callbacks scheduled by setTimeout() or setInterval().
        - **Pending Callbacks**: Handles I/O operations like network requests.
        - **Idle/Prepare**: Internal Node.js operations.
        - **Poll**: Retrieves new I/O events and executes I/O-related callbacks.
        - **Check**: Executes callbacks from setImmediate()..
        - **Close Callbacks**: Closes operations like file descriptors or sockets.

## Callbacks, Promises, and Async/Await

In Node.js, asynchronous programming is essential for handling tasks that take time, like reading a file, making an API request, or accessing a database. Instead of waiting for these tasks to finish before moving on, Node.js allows you to continue working on other things. There are three main ways to handle asynchronous operations: **callbacks**, **promises**, and **async/await**.

### 1. Callbacks

A **callback** is a function passed as an argument to another function. The callback gets executed once the asynchronous operation finishes. For example, when reading a file, the function to read the file takes a callback, which runs once the file data is available.

```js
const fs = require("fs");

fs.readFile("file.txt", "utf8", (err, data) => {
  if (err) {
    console.error("Error reading file", err);
    return;
  }
  console.log(data);
});
```

Here, the **readFile** function reads the file asynchronously, and the callback is executed when the file is read. If there’s an error, it's handled inside the callback.

### 2. Promises

A **promise** is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It provides a cleaner way to work with async code compared to callbacks.

```js
const readFilePromise = fs.promises.readFile("file.txt", "utf8");

readFilePromise
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.error("Error reading file", err);
  });
```

Here, **readFilePromise** handles the asynchronous file read, and we use **.then()** to handle the success and **.catch()** to handle errors. Promises allow you to chain multiple async operations in a readable way.

### 3. Async/Await

**Async/await** is a more modern and cleaner way to write asynchronous code in JavaScript. It is built on promises but allows you to write asynchronous code that looks synchronous.

```js
const fs = require("fs").promises;

async function readFileAsync() {
  try {
    const data = await fs.readFile("file.txt", "utf8");
    console.log(data);
  } catch (err) {
    console.error("Error reading file", err);
  }
}

readFileAsync();
```

In this example, **await** pauses the execution of the function until the promise resolves, making the code easier to read. If an error occurs, it’s handled with **try/catch**.

## Modules and the Module System in Node.js

In Node.js, the module system allows developers to structure and reuse code efficiently. A module is essentially a file containing code (functions, objects, or variables) that can be exported and imported into other files. Node.js follows a modular architecture, enabling developers to divide code into smaller, maintainable parts.

### Creating and Exporting a Module

To create a module, you define the logic you want to share in a JavaScript file. For example, let's create a module that exports a simple function:

```js
//math.js

const fs = require("fs").promises;
function add(a, b) {
  return a + b;
}

// Export the function
module.exports = { add };
```

Here, the add function is exported using module.exports, which makes it available to other files.

**Importing a Module**
Once a module is created and exported, it can be imported and used in other files using the require function:

```js
//app.js

const math = require("./math");
console.log(math.add(2, 3)); // Output: 5
```

### CommonJS vs. ES Modules

Node.js supports two module systems: **CommonJS** (the older, default module system) and **ES Modules** (a more modern, standards-based approach). Let's compare their differences:

#### Quick Comparison

| Feature        | CommonJS                          | ES Modules                                                  |
| -------------- | --------------------------------- | ----------------------------------------------------------- |
| Syntax         | `module.exports` / `require`      | `export` / `import`                                         |
| File Extension | `.js`                             | `.mjs` (or `.js` with `"type": "module"` in `package.json`) |
| Import Type    | Synchronous                       | Asynchronous                                                |
| Default Usage  | Older Node.js apps, simpler setup | Modern apps, full browser support                           |

The following code snippets demonstrate exporting and importing an `add` function to perform addition in CommonJS and ES modules, respectively.

##### Example: CommonJS

```js
// math.js
module.exports = { add: (a, b) => a + b };

// app.js
const math = require("./math");
console.log(math.add(2, 3));
```

##### Example: ES Modules

```js
// math.mjs
export function add(a, b) {
  return a + b;
}

// app.mjs
import { add } from "./math.mjs";
console.log(add(2, 3));
```

### Built-in Modules in Node.js

Node.js provides several built-in modules that are essential for building applications. These modules cover common tasks like file handling, networking, and event handling. Here are a few important ones:

#### 1. File System (fs)

The `fs` module allows you to interact with the file system, enabling you to read, write, update, and delete files.

```js
// Import the 'fs' module
const fs = require("fs");

fs.readFile("example.txt", "utf8", (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

The following above code snippet demonstrates using the fs module to read the contents of a file asynchronously.

#### 2. HTTP

The `http` module enables the creation of web servers and handling of HTTP requests.

**Example: Simple HTTP server**

```js
const http = require("http");

http
  .createServer((req, res) => {
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("Hello, World!\n");
  })
  .listen(3000, () => {
    console.log("Server running at http://localhost:3000/");
  });
```

The following above code snippet demonstrates creating a basic HTTP server that responds with **"Hello, World!"** when accessed.

#### 3. Events

The `events` module provides a way to work with event-driven programming. Node.js applications frequently rely on event emitters to trigger and handle asynchronous actions.

**Example: Using EventEmitter**

```js
const EventEmitter = require("events");
const eventEmitter = new EventEmitter();

// Event listener
eventEmitter.on("greet", () => {
  console.log("Hello, World!");
});

// Emit event
eventEmitter.emit("greet");
```

The following above code snippet demonstrates using the `EventEmitter` module to create an event listener that logs **"Hello, World!"** when the "greet" event is emitted.

## References

For more information, check out the following resources:

- [Unit Testing](https://www.testim.io/blog/node-js-unit-testing-get-started-quickly-with-examples/)
- [Database Integration](https://expressjs.com/en/guide/database-integration.html)
- [Node.js Documentation](https://nodejs.org/docs/latest/api/)
- [Express.js Documentation](https://expressjs.com/en/starter/installing.html)
